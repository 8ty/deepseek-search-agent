"""
GitHub Actions ÊâßË°åÂô®
‰∏ìÈó®Áî®‰∫éÂú® GitHub Actions ÁéØÂ¢É‰∏≠ËøêË°åÊêúÁ¥¢‰ª£ÁêÜ
"""

import os
import sys
import json
import asyncio
import aiohttp
import traceback
import re
import argparse
from typing import Dict, Any, Optional, List
from datetime import datetime

from config.settings import get_settings


# Â∑•ÂÖ∑Á±ª - Â§çÂà∂Ëá™ÂéüÂßãnotebook
class SearchTool:
    def __init__(self, timeout: int = 60 * 5):
        self.timeout = timeout

    async def __call__(self, input: str, *args) -> str:
        results = await self.search(input)
        formatted_results = self._format_results(results)
        return formatted_results

    async def search(self, query: str) -> List[Dict[str, Any]]:
        from urllib.parse import quote_plus
        url = f"https://s.jina.ai/{quote_plus(query)}"
        
        headers = {
            "Accept": "application/json", 
            "X-Retain-Images": "none",
            "X-No-Cache": "true",
        }
        
        if api_key := os.getenv("JINA_API_KEY"):
            headers["Authorization"] = f"Bearer {api_key}"
        
        # ÈáçËØïÈÖçÁΩÆ
        max_retries = 3
        retry_delay = 2
        
        for attempt in range(max_retries):
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(url, headers=headers, timeout=self.timeout) as response:
                        if response.status == 200:
                            json_response = await response.json()
                            
                            results = [
                                {
                                    "url": result["url"],
                                    "title": result["title"], 
                                    "description": result["description"],
                                }
                                for result in json_response["data"]
                            ]
                            
                            return results
                        
                        elif response.status == 524:
                            # 524 ÊòØ Cloudflare Ë∂ÖÊó∂ÈîôËØØ
                            error_msg = f"Jina API timeout (524) on attempt {attempt + 1}/{max_retries}"
                            print(f"‚ö†Ô∏è {error_msg}")
                            
                            if attempt < max_retries - 1:
                                print(f"üîÑ Retrying in {retry_delay} seconds...")
                                await asyncio.sleep(retry_delay)
                                retry_delay *= 2  # ÊåáÊï∞ÈÄÄÈÅø
                                continue
                            else:
                                return [{"url": "", "title": "Search Error", "description": f"Search API returned 524 timeout error after {max_retries} attempts. This typically means the search service is overloaded. Try simpler search terms."}]
                        
                        elif response.status == 429:
                            # ÈÄüÁéáÈôêÂà∂
                            error_msg = f"Jina API rate limit (429) on attempt {attempt + 1}/{max_retries}"
                            print(f"‚ö†Ô∏è {error_msg}")
                            
                            if attempt < max_retries - 1:
                                wait_time = retry_delay * 2
                                print(f"üîÑ Rate limited, waiting {wait_time} seconds...")
                                await asyncio.sleep(wait_time)
                                continue
                            else:
                                return [{"url": "", "title": "Rate Limit Error", "description": f"Search API rate limit exceeded after {max_retries} attempts. Please wait and try again with different search terms."}]
                        
                        else:
                            # ÂÖ∂‰ªñHTTPÈîôËØØ
                            error_text = await response.text()
                            error_msg = f"Jina API error {response.status}: {error_text}"
                            print(f"‚ùå {error_msg}")
                            
                            if attempt < max_retries - 1:
                                print(f"üîÑ Retrying in {retry_delay} seconds...")
                                await asyncio.sleep(retry_delay)
                                retry_delay *= 2
                                continue
                            else:
                                return [{"url": "", "title": f"API Error {response.status}", "description": f"Search API returned error {response.status}. Error details: {error_text[:200]}..."}]
                
            except asyncio.TimeoutError:
                error_msg = f"Search request timeout on attempt {attempt + 1}/{max_retries}"
                print(f"‚ö†Ô∏è {error_msg}")
                
                if attempt < max_retries - 1:
                    print(f"üîÑ Retrying in {retry_delay} seconds...")
                    await asyncio.sleep(retry_delay)
                    retry_delay *= 2
                    continue
                else:
                    return [{"url": "", "title": "Timeout Error", "description": f"Search request timed out after {max_retries} attempts. Try simpler search terms or check your internet connection."}]
            
            except Exception as e:
                error_msg = f"Search error on attempt {attempt + 1}/{max_retries}: {str(e)}"
                print(f"‚ùå {error_msg}")
                
                if attempt < max_retries - 1:
                    print(f"üîÑ Retrying in {retry_delay} seconds...")
                    await asyncio.sleep(retry_delay)
                    retry_delay *= 2
                    continue
                else:
                    return [{"url": "", "title": "Search Error", "description": f"Search failed after {max_retries} attempts. Error: {str(e)}. Try different search terms or check your network connection."}]
        
        # ËøôË°å‰ª£Á†ÅÂÆûÈôÖ‰∏ç‰ºöÊâßË°åÂà∞Ôºå‰ΩÜ‰∏∫‰∫ÜÂÆåÊï¥ÊÄß
        return [{"url": "", "title": "Unknown Error", "description": "Search failed due to unknown error."}]

    def _format_results(self, results: List[Dict[str, Any]]) -> str:
        formatted_results = []
        
        for i, result in enumerate(results, 1):
            formatted_results.extend([
                f"Title: {result['title']}", 
                f"URL Source: {result['url']}",
                f"Description: {result['description']}",
                "",
            ])
        
        return "\n".join(formatted_results).rstrip()


class ScrapTool:
    def __init__(self, gather_links: bool = True):
        self.gather_links = gather_links

    async def __call__(self, input: str, context: str | None) -> str:
        result = await self.scrap_webpage(input, context)
        return result

    async def scrap_webpage(self, url: str, context: str | None) -> str:
        url = f"https://r.jina.ai/{url}"
        
        headers = {"X-Retain-Images": "none", "X-With-Links-Summary": "true"}
        
        if api_key := os.getenv("JINA_API_KEY"):
            headers["Authorization"] = f"Bearer {api_key}"
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=headers) as response:
                    if response.status != 200:
                        print(f"Failed to fetch {url}: {response.status}")
                        raise Exception(f"Failed to fetch {url}: {response.status}")
                    result = await response.text()
            
            # ÁÆÄÂåñÂ§ÑÁêÜÔºå‰∏ç‰ΩøÁî®rerank
            return result
            
        except Exception as e:
            raise e


# OpenRouterÊ®°ÂûãÁ±ª
class OpenRouterModel:
    def __init__(self, model_name="deepseek/deepseek-r1:free", api_key=None, base_url="https://openrouter.ai/api/v1/chat/completions"):
        self.model_name = model_name
        self.api_key = api_key or os.getenv("OPENROUTER_API_KEY")
        self.base_url = base_url

    def _get_headers(self):
        return {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
        }

    def _build_payload(self, messages, reasoning_effort="low"):
        return {
            "model": self.model_name,
            "messages": messages,
            "reasoning": {"effort": reasoning_effort},
        }

    async def __call__(self, message: str, reasoning_effort="low"):
        messages = [{"role": "user", "content": message}]
        headers = self._get_headers()
        payload = self._build_payload(messages, reasoning_effort)

        async with aiohttp.ClientSession() as session:
            async with session.post(self.base_url, headers=headers, json=payload) as response:
                if response.status != 200:
                    error_text = await response.text()
                    raise Exception(f"API request failed with status {response.status}: {error_text}")
                response_json = await response.json()
                
                think_content = response_json["choices"][0]["message"].get("reasoning", "")
                content = response_json["choices"][0]["message"]["content"]
                
                # ÁªÑÂêàÊÄùËÄÉËøáÁ®ãÂíåÂõûÁ≠î
                full_content = think_content + "\n" + content if think_content else content
                return full_content


# JSONÊèêÂèñÂ∑•ÂÖ∑
def extract_json_values(text: str):
    decoder = json.JSONDecoder()

    def next_json_position(pos: int) -> int | None:
        matches = [p for p in (text.find(c, pos) for c in "{[") if p != -1]
        return min(matches) if matches else None

    pos = 0
    while (next_pos := next_json_position(pos)) is not None:
        try:
            result, index = decoder.raw_decode(text[next_pos:])
            yield result
            pos = next_pos + index
        except json.JSONDecodeError:
            pos = next_pos + 1


def extract_largest_json(text: str) -> dict:
    try:
        json_values = list(extract_json_values(text))
        if not json_values:
            raise ValueError("No JSON found in response")
        return max(json_values, key=lambda x: len(json.dumps(x)))
    except Exception as e:
        raise ValueError(f"Failed to extract JSON: {str(e)}\nText: {text}")


# Â∑•‰ΩúÁ©∫Èó¥Á±ª
class Workspace:
    def __init__(self):
        self.state = {"status": "IN_PROGRESS", "blocks": {}, "answer": None}

    def to_string(self):
        result = f"Status: {self.state['status']}\n"
        result += "Memory: \n"

        if not self.state["blocks"]:
            result += "... no memory blocks ...\n"
        else:
            for block_id, content in self.state["blocks"].items():
                result += f"<{block_id}>{content}</{block_id}>\n"

        return result

    def _generate_unique_block_id(self):
        import random
        import string
        while True:
            letters = "".join(random.choices(string.ascii_lowercase, k=3))
            digits = "".join(random.choices(string.digits, k=3))
            new_id = f"{letters}-{digits}"

            if new_id not in self.state["blocks"]:
                return new_id

    def update_blocks(self, status: str, blocks: List[Dict], answer: Optional[str] = None):
        self.state["status"] = status

        for block_op in blocks:
            operation = block_op.get("operation")

            if operation == "add":
                new_id = self._generate_unique_block_id()
                self.state["blocks"][new_id] = block_op.get("content", "")

            elif operation == "delete":
                block_id = block_op.get("id")
                if block_id in self.state["blocks"]:
                    del self.state["blocks"][block_id]

        if answer is not None:
            self.state["answer"] = answer

    def is_done(self):
        return self.state["status"] != "IN_PROGRESS"


# ÊèêÁ§∫Ê®°ÊùøÁ±ª
class Prompt:
    def __init__(self, template: str):
        self.template = template
        from jinja2 import Environment, BaseLoader
        self.env = Environment(loader=BaseLoader())

    def __call__(self, **variables) -> str:
        prompt_template = self.env.from_string(self.template)
        prompt = prompt_template.render(**variables)
        prompt = prompt.strip()
        return prompt

    async def run(self, prompt_variables: Dict[str, Any] = {}, generation_args: Dict[str, Any] = {}) -> str:
        model = OpenRouterModel()
        prompt = self(**prompt_variables)
        print(f"\nü§ñ Prompt:\n{prompt[:500]}...\n")
        try:
            result = await model(prompt)
            print(f"\nüìù Result:\n{result[:500]}...\n")
            return result
        except Exception as e:
            print(f"‚ùå Model error: {e}")
            raise


# ÊêúÁ¥¢‰ª£ÁêÜÁ±ª
class GitHubSearchAgent:
    """GitHub Actions ÊêúÁ¥¢‰ª£ÁêÜ"""
    
    def __init__(self, task: str, callback_url: str = None, current_date: str = None, search_id: str = None, debug_mode: bool = False, silent_mode: bool = False):
        self.task = task
        self.current_date = current_date or datetime.now().strftime("%Y-%m-%d")
        self.callback_url = callback_url
        self.search_id = search_id or f"search-{int(datetime.now().timestamp() * 1000)}"
        self.debug_mode = debug_mode
        self.silent_mode = silent_mode
        self.tool_records = None
        self.workspace = Workspace()
        self.round = 0
        self.iteration_results = []

        # Âú®ÂàùÂßãÂåñÊó∂ÂàõÂª∫Â∑•ÂÖ∑ÂÆû‰æãÔºåËÄå‰∏çÊòØÂú®Á±ªÂÆö‰πâÊó∂
        self.tools = {"search": SearchTool(), "scrape": ScrapTool()}

        # ÂàõÂª∫ÊèêÁ§∫Ê®°Êùø
        self.prompt = Prompt(self._get_prompt_template())

    def _get_prompt_template(self) -> str:
        return """{% macro format_tool_results(tool_records) %}
{% for to in tool_records %}
Source {{ loop.index }}Ô∏è: {{ to.tool }}: {{ to.input }}
Result:
```
{{ to.output }}
```
{% endfor %}
{% endmacro %}

The date: `{{ current_date }}`.
You are an information analysis and exploration agent that builds solutions through systematic investigation.

## Investigation Cycle
You operate in a continuous investigation cycle:

1. Review current workspace (your memory blocks)
2. Analyze new tool results (or initial task if first round)
3. Update memory with new insights and track investigation progress
4. Decide on next tools to call based on identified leads and information gaps
5. Repeat until task completion

## Memory Structure
Your memory persists between investigation cycles and consists of:
- **Status**: Always the first line, indicates if the task is IN_PROGRESS or DONE
- **Memory**: A collection of discrete information blocks, each with a unique ID

## Memory Block Usage
- Each memory block has a unique ID in format <abc-123>content</abc-123>
- Create separate blocks for distinct pieces of information:
  * Discovered URLs (both explored and pending)
  * Information gaps that need investigation
  * Actions already taken (to avoid repetition)
  * Promising leads for future exploration
  * Key facts and findings
  * Contradictions or inconsistencies found
  * Tool failures and alternative strategies to try
- Keep each block focused on a single idea or piece of information
- Always cite sources when recording information from tool results
- Use IDs to track and manage your knowledge (e.g., deleting outdated information)
- Make sure to store sources (URLs) for the facts and findings you store

## Lead Management
- Since you can only make 3 tool calls per round, store promising leads for later
- Create dedicated memory blocks for URLs to scrape later
- Maintain blocks for potential search queries to explore in future rounds
- Prioritize leads based on relevance to the task

## Available Tools
- **search**: Use for broad information gathering on new topics or concepts
  * Example: {"tool": "search", "input": "renewable energy statistics 2023"}
- **scrape**: Use for extracting specific details from discovered URLs
  * Example: {"tool": "scrape", "input": "https://example.com/energy-report"}

## Tool Usage Guidelines
- **When to use search**: For new concepts, filling knowledge gaps, or exploring new directions
- **When to use scrape**: For URLs discovered that likely contain detailed information
- **Maximum 3 tool calls per round**
- **Never repeat the exact same tool call**
- **Always record valuable information from tool results in memory blocks**

## Error Recovery Strategies
When tools fail or return errors:
1. **Try alternative search terms**: Break down complex queries into simpler ones
2. **Use broader search terms**: If specific searches fail, try more general topics
3. **Analyze error patterns**: Record what failed and why in memory blocks
4. **Attempt different approaches**: If direct searches fail, try related topics
5. **Continue investigating**: Tool failures don't mean the task is impossible
6. **Only give up after exhausting reasonable alternatives**

## Task Completion Guidelines
- **IMPORTANT**: Do NOT set status to "DONE" just because tools are failing
- **Persistence is key**: Try multiple search strategies before concluding
- **Record failures**: Document what you tried and what failed in memory blocks
- **Set status to "DONE" ONLY when**:
  - You have found sufficient information to answer the task comprehensively, OR
  - You have exhausted all reasonable search strategies and approaches, OR
  - The task appears to be asking for something that doesn't exist or is meaningless
- **If tools consistently fail**: Try simpler, more basic searches related to the topic
- **For unclear tasks**: Try to interpret them in different ways and search accordingly

## Response Format
You must respond with a valid JSON object containing:

```json
{
  "status_update": "IN_PROGRESS or DONE",
  "memory_updates": [
    {"operation": "add", "content": "New insight or lead to investigate"},
    {"operation": "delete", "id": "abc-123"}
  ],
  "tool_calls": [
    {"tool": "search", "input": "specific search query"},
    {"tool": "scrape", "input": "https://discovered-url.com"}
  ],
  "answer": "Your final, comprehensive answer when status is DONE"
}
```

## Important Rules
- The "add" operation creates a new memory block. You do not need to specify an ID, it will be added automatically by the system.
- The "delete" operation requires the specific ID of the block to remove
- Never invent or fabricate information - only use facts from your memory or tool results
- Never make up URLs - only use URLs discovered through tool results
- CRITICAL: Any information not recorded in your memory blocks will be lost in the next round
  For example, if you find a potential webpage to scrap, you must store the URL and your intention
  Example: `{"operation": "add", "content": "Found relevant URL: https://... to scrape ..."}`
- IMPORTANT: Make sure to delete memory blocks that are no longer necessary
- **PERSISTENCE**: Don't give up too early! Try multiple approaches and search strategies
- Only include the "answer" field when status is "DONE"

## ÈáçË¶ÅÊèêÈÜí
- **ËæìÂá∫ËØ≠Ë®Ä**: ËØ∑‰ΩøÁî®‰∏≠ÊñáÂõûÁ≠îÈóÆÈ¢òÔºåÊèê‰æõ‰∏≠ÊñáÁöÑÊúÄÁªàÁ≠îÊ°à
- **‰ø°ÊÅØÈ™åËØÅ**: ÁâπÂà´Ê≥®ÊÑèÊó∂Èó¥ÊïèÊÑü‰ø°ÊÅØÁöÑÈ™åËØÅÔºåÁ°Æ‰øù‰ø°ÊÅØÁöÑÊó∂ÊïàÊÄß
- **ÂΩªÂ∫ïÊé¢Á¥¢**: Âú®ÂæóÂá∫ÊúÄÁªàÁ≠îÊ°àÂâçÔºåÂ∞ΩÂèØËÉΩÂΩªÂ∫ïÊé¢Á¥¢ÊâÄÊúâÁõ∏ÂÖ≥Á∫øÁ¥¢
- **Êù•Ê∫êÂºïÁî®**: Âú®ÊúÄÁªàÁ≠îÊ°à‰∏≠ÊòéÁ°ÆÂºïÁî®‰ø°ÊÅØÊù•Ê∫êÁöÑURL
- **ÊåÅÁª≠ÊÄß**: ‰∏çË¶ÅÂõ†‰∏∫Â∑•ÂÖ∑Â§±Ë¥•Â∞±ËøáÊó©ÊîæÂºÉÔºåÂ∞ùËØïÂ§öÁßçÊêúÁ¥¢Á≠ñÁï•

Task:
```
{{ task }}
```

Current workspace:
```
{{ workspace }}
```

Tool Results:
{{ format_tool_results(tool_records) if tool_records else '... no previous tool results ...'}}

IMPORTANT: Generate a valid JSON response following the format above.

Think carefully about:
- what information do you need to preserve
- which tools to call next
- how to build your answer systematically with focused memory blocks
- whether you've tried enough different approaches before giving up

Do NOT rely on your internal knowledge (may be biased), aim to discover information using the tools!"""

    async def send_update(self, update_type: str, data: Dict[str, Any]):
        """ÂèëÈÄÅÊõ¥Êñ∞Âà∞ÂõûË∞ÉURL"""
        if not self.silent_mode:
            print(f"üì§ ÂèëÈÄÅÊõ¥Êñ∞: {update_type}")
        
        try:
            if self.callback_url:
                parsed_url = aiohttp.client_reqrep.URL(self.callback_url)
                # Ê∑ªÂä†ÊêúÁ¥¢ID‰Ωú‰∏∫Êü•ËØ¢ÂèÇÊï∞
                callback_with_id = str(parsed_url.with_query(id=self.search_id))
                
                async with aiohttp.ClientSession() as session:
                    async with session.post(
                        callback_with_id,
                        json={
                            "type": update_type,
                            "data": data,
                            "timestamp": datetime.now().isoformat()
                        },
                        timeout=aiohttp.ClientTimeout(total=30)
                    ) as response:
                        if not self.silent_mode:
                            print(f"‚úÖ Êõ¥Êñ∞ÂèëÈÄÅÊàêÂäü: {response.status}")
            else:
                if not self.silent_mode:
                    print("‚ö†Ô∏è Êó†ÂõûË∞ÉURLÔºåË∑≥ËøáÊõ¥Êñ∞ÂèëÈÄÅ")
                    
        except Exception as e:
            if not self.silent_mode:
                print(f"‚ùå ÂèëÈÄÅÊõ¥Êñ∞Â§±Ë¥•: {str(e)}")

    async def wait_for_user_decision(self, timeout_seconds: int = 300) -> str:
        """Á≠âÂæÖÁî®Êà∑ÂÜ≥Á≠ñÔºöÁªßÁª≠ÊêúÁ¥¢ Êàñ ÁîüÊàêÁªìÊûú"""
        if not self.callback_url:
            if self.debug_mode and not self.silent_mode:
                print("‚ö†Ô∏è Êó†ÂõûË∞ÉURLÔºåÊó†Ê≥ïÁ≠âÂæÖÁî®Êà∑ÂÜ≥Á≠ñ")
            return 'timeout'
            
        # ÊûÑÂª∫Áî®Êà∑ÂÜ≥Á≠ñAPIÁ´ØÁÇπ
        base_url = self.callback_url.replace('/api/webhook', '')
        decision_endpoint = f"{base_url}/api/user-decision/{self.search_id}"
        
        if self.debug_mode and not self.silent_mode:
            print(f"‚è≥ Á≠âÂæÖÁî®Êà∑ÂÜ≥Á≠ñÔºåÁõëÂê¨Á´ØÁÇπ: {decision_endpoint}")
            print(f"‚è∞ Ë∂ÖÊó∂Êó∂Èó¥: {timeout_seconds}Áßí")
        
        # ËΩÆËØ¢Áî®Êà∑ÂÜ≥Á≠ñÔºàÊØè10ÁßíÊ£ÄÊü•‰∏ÄÊ¨°Ôºâ
        for i in range(timeout_seconds // 10):
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(decision_endpoint, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        if response.status == 200:
                            data = await response.json()
                            action = data.get('action')
                            if action:
                                if self.debug_mode and not self.silent_mode:
                                    print(f"‚úÖ Êî∂Âà∞Áî®Êà∑ÂÜ≥Á≠ñ: {action}")
                                return action
            except Exception as e:
                if self.debug_mode and not self.silent_mode:
                    print(f"üîÑ ËΩÆËØ¢Áî®Êà∑ÂÜ≥Á≠ñÂ§±Ë¥• (Â∞ùËØï {i+1}): {str(e)}")
                pass
            
            if self.debug_mode and not self.silent_mode:
                remaining_time = timeout_seconds - (i + 1) * 10
                print(f"‚è≥ Á≠âÂæÖÁî®Êà∑ÂÜ≥Á≠ñ‰∏≠... (Ââ©‰Ωô {remaining_time}Áßí)")
            
            await asyncio.sleep(10)
        
        if self.debug_mode and not self.silent_mode:
            print("‚è∞ Áî®Êà∑ÂÜ≥Á≠ñÁ≠âÂæÖË∂ÖÊó∂")
        return 'timeout'

    async def continue_search_in_same_env(self, additional_rounds: int = 3) -> Dict[str, Any]:
        """Âú®Âêå‰∏ÄÁéØÂ¢É‰∏≠ÁªßÁª≠ÊêúÁ¥¢È¢ùÂ§ñËΩÆÊ¨°"""
        if self.debug_mode and not self.silent_mode:
            print(f"üîÑ ÁªßÁª≠ÊêúÁ¥¢È¢ùÂ§ñ {additional_rounds} ËΩÆ")
        
        # ËÆ∞ÂΩïÁªßÁª≠ÊêúÁ¥¢ÂâçÁöÑÁä∂ÊÄÅ
        pre_continue_round = self.round
        pre_continue_iterations = len(self.iteration_results)
        
        # ÂèëÈÄÅÁªßÁª≠ÊêúÁ¥¢Áä∂ÊÄÅÊõ¥Êñ∞
        await self.send_update("continue_start", {
            "message": f"ÂºÄÂßãÁªßÁª≠ÊêúÁ¥¢È¢ùÂ§ñ {additional_rounds} ËΩÆ",
            "previous_rounds": pre_continue_round,
            "additional_rounds": additional_rounds
        })
        
        # ÁªßÁª≠ÊêúÁ¥¢ÈÄªËæëÔºàÂü∫‰∫éÂéüÊúâÁöÑrunÊñπÊ≥ïÈÄªËæëÔºâ
        max_total_rounds = pre_continue_round + additional_rounds
        consecutive_failures = 0
        total_tool_calls = sum(len(it.get("tool_calls", [])) for it in self.iteration_results)
        
        while self.round < max_total_rounds:
            try:
                if self.debug_mode and not self.silent_mode:
                    print(f"\nüîÑ === ÁªßÁª≠ÊêúÁ¥¢ Round {self.round + 1} ===")
                
                # ‰ΩøÁî®Â¢ûÂº∫ÁöÑÊèêÁ§∫ÔºåËØ¥ÊòéËøôÊòØÁªßÁª≠ÊêúÁ¥¢
                enhanced_task = f"{self.task}\n\n[ÁªßÁª≠ÊêúÁ¥¢Ê®°Âºè] Â∑≤ÂÆåÊàê {pre_continue_round} ËΩÆÊêúÁ¥¢ÔºåÁé∞Âú®ÁªßÁª≠Ê∑±ÂÖ•Êé¢Á¥¢„ÄÇËØ∑Âü∫‰∫éÂ∑≤Êúâ‰ø°ÊÅØÂØªÊâæÊõ¥Â§öÁªÜËäÇÊàñ‰∏çÂêåËßíÂ∫¶ÁöÑ‰ø°ÊÅØ„ÄÇ"
                
                response = await self.prompt.run({
                    "current_date": self.current_date,
                    "task": enhanced_task,
                    "workspace": self.workspace.to_string(),
                    "tool_records": self.tool_records,
                })
                
                if self.debug_mode and not self.silent_mode:
                    print(f"‚úÖ ÁªßÁª≠ÊêúÁ¥¢APIË∞ÉÁî®ÊàêÂäüÔºåÂìçÂ∫îÈïøÂ∫¶: {len(response)}")

                # Ê∏ÖÈô§ÊÄùËÄÉÈÉ®ÂàÜÂπ∂ÊèêÂèñJSON
                response = re.sub(r"(?:<think>)?.*?</think>", "", response, flags=re.DOTALL)
                response_json = extract_largest_json(response)
                
                if not response_json:
                    if self.debug_mode and not self.silent_mode:
                        print("‚ùå ÁªßÁª≠ÊêúÁ¥¢: JSONÊèêÂèñÂ§±Ë¥•")
                    break
                
                # Êõ¥Êñ∞Â∑•‰ΩúÂå∫
                self.workspace.update_blocks(
                    response_json.get("status_update", "IN_PROGRESS"),
                    response_json.get("memory_updates", []),
                    response_json.get("answer", None),
                )
                
                # ËÆ∞ÂΩïËø≠‰ª£ÁªìÊûú
                iteration_result = {
                    "round": self.round + 1,
                    "workspace_state": self.workspace.to_string(),
                    "tool_calls": response_json.get("tool_calls", []),
                    "response_json": response_json,
                    "raw_response": response[:500] + "..." if len(response) > 500 else response,
                    "is_continuation": True
                }
                
                self.iteration_results.append(iteration_result)
                await self.send_update("iteration", iteration_result)

                # Ê£ÄÊü•ÊòØÂê¶ÂÆåÊàê
                if self.workspace.is_done():
                    if self.debug_mode and not self.silent_mode:
                        print("üéâ ÁªßÁª≠ÊêúÁ¥¢‰ªªÂä°ÂÆåÊàê!")
                    final_answer = response_json.get("answer", "")
                    await self.send_update("complete", {
                        "answer": final_answer,
                        "iterations": self.iteration_results,
                        "total_rounds": self.round + 1,
                        "continued_search": True
                    })
                    break

                # ÊâßË°åÂ∑•ÂÖ∑Ë∞ÉÁî®
                tool_calls = response_json.get("tool_calls", [])
                if not tool_calls:
                    consecutive_failures += 1
                    if consecutive_failures >= 2:
                        break
                else:
                    consecutive_failures = 0
                
                total_tool_calls += len(tool_calls)
                
                # ÊâßË°åÂ∑•ÂÖ∑Ë∞ÉÁî®ÔºàÂ§çÁî®ÂéüÊúâÈÄªËæëÔºâ
                tool_outputs = []
                for call in tool_calls:
                    try:
                        output = await self.run_tool(call["tool"], call["input"])
                        tool_outputs.append(output)
                    except Exception as e:
                        tool_outputs.append(f"Tool error: {str(e)}")
                
                self.tool_records = [
                    {**call, "output": output}
                    for call, output in zip(tool_calls, tool_outputs)
                ]

            except Exception as e:
                if self.debug_mode and not self.silent_mode:
                    print(f"‚ùå ÁªßÁª≠ÊêúÁ¥¢Âá∫Èîô: {str(e)}")
                await self.send_update("error", {"error": str(e), "traceback": traceback.format_exc()})
                break
            
            self.round += 1
            await asyncio.sleep(2)  # ÈÅøÂÖçAPIÈôêÂà∂
        
        # ËøîÂõûÁªßÁª≠ÊêúÁ¥¢ÁöÑÁªìÊûú
        return {
            "search_id": self.search_id,
            "iterations": self.iteration_results,
            "final_state": self.workspace.to_string(),
            "is_complete": self.workspace.is_done(),
            "answer": self.workspace.state.get("answer"),
            "total_rounds": self.round,
            "total_tool_calls": total_tool_calls,
            "continued_search": True,
            "additional_rounds_completed": self.round - pre_continue_round
        }

    async def finalize_with_current_state(self) -> Dict[str, Any]:
        """Âü∫‰∫éÂΩìÂâçÁä∂ÊÄÅÁîüÊàêÊúÄÁªàÁªìÊûú"""
        if self.debug_mode and not self.silent_mode:
            print("üìù ÂºÄÂßãÂü∫‰∫éÂΩìÂâçÁä∂ÊÄÅÁîüÊàêÊúÄÁªàÁªìÊûú...")
        
        # ÂèëÈÄÅÊúÄÁªàÂåñÂºÄÂßãÁä∂ÊÄÅ
        await self.send_update("finalize_start", {
            "message": "ÂºÄÂßãÂü∫‰∫éÁé∞Êúâ‰ø°ÊÅØÁîüÊàêÊúÄÁªàÁªìÊûú",
            "rounds_completed": self.round,
            "iterations_count": len(self.iteration_results)
        })
        
        try:
            # ÊûÑÂª∫ÊÄªÁªìÊèêÁ§∫
            iterations_summary = ""
            if self.iteration_results:
                iterations_summary = "‰ª•‰∏ãÊòØÊêúÁ¥¢ËøáÁ®ã‰∏≠Êî∂ÈõÜÁöÑ‰ø°ÊÅØ:\n"
                for i, iteration in enumerate(self.iteration_results[:5], 1):  # ÊúÄÂ§ö‰ΩøÁî®Ââç5ËΩÆ
                    iterations_summary += f"\n=== Á¨¨{i}ËΩÆÊêúÁ¥¢ ===\n"
                    workspace_state = iteration.get('workspace_state', '')
                    if len(workspace_state) > 500:
                        workspace_state = workspace_state[:500] + "..."
                    iterations_summary += f"Â∑•‰ΩúÁ©∫Èó¥Áä∂ÊÄÅ: {workspace_state}\n"
                    
                    tool_calls = iteration.get('tool_calls', [])
                    if tool_calls:
                        iterations_summary += f"Â∑•ÂÖ∑Ë∞ÉÁî®: {len(tool_calls)} Ê¨°\n"
                        for tool_call in tool_calls[:3]:  # ÊúÄÂ§öÊòæÁ§∫3‰∏™Â∑•ÂÖ∑Ë∞ÉÁî®
                            tool_name = tool_call.get('tool', '')
                            tool_input = tool_call.get('input', '')[:100]
                            iterations_summary += f"- {tool_name}: {tool_input}...\n"
                            
                            # Â¶ÇÊûúÊúâÂ∑•ÂÖ∑ËÆ∞ÂΩïÔºåÊòæÁ§∫ËæìÂá∫
                            for record in self.tool_records:
                                if (record.get('tool') == tool_name and 
                                    record.get('input') == tool_call.get('input')):
                                    output = record.get('output', '')[:200]
                                    iterations_summary += f"  ÁªìÊûú: {output}...\n"
                                    break
            
            # ÊûÑÂª∫ÊúÄÁªàÂåñÊèêÁ§∫
            finalize_prompt = f"""‰Ω†ÊòØ‰∏Ä‰∏™‰∏ì‰∏öÁöÑ‰ø°ÊÅØÂàÜÊûêÂ∏à„ÄÇËØ∑Âü∫‰∫é‰ª•‰∏ãÊêúÁ¥¢ËøáÁ®ãÂíåÊî∂ÈõÜÁöÑ‰ø°ÊÅØÔºå‰∏∫Áî®Êà∑Êü•ËØ¢ÁîüÊàê‰∏Ä‰∏™ÂÖ®Èù¢„ÄÅÂáÜÁ°ÆÁöÑÊúÄÁªàÁ≠îÊ°à„ÄÇ

Áî®Êà∑Êü•ËØ¢: {self.task}

{iterations_summary}

ÂΩìÂâçÂ∑•‰ΩúÁ©∫Èó¥Áä∂ÊÄÅ:
{self.workspace.to_string()}

ËØ∑‰Ω†:
1. ÂàÜÊûê‰ª•‰∏äÊêúÁ¥¢Ëø≠‰ª£‰∏≠Êî∂ÈõÜÂà∞ÁöÑÊâÄÊúâÁõ∏ÂÖ≥‰ø°ÊÅØ
2. Êï¥ÂêàËøô‰∫õ‰ø°ÊÅØÔºåÁ°Æ‰øùÁ≠îÊ°àÁöÑÂÆåÊï¥ÊÄßÂíåÂáÜÁ°ÆÊÄß
3. Êèê‰æõ‰∏Ä‰∏™ÁªìÊûÑÊ∏ÖÊô∞„ÄÅÂÜÖÂÆπ‰∏∞ÂØåÁöÑÊúÄÁªàÁ≠îÊ°à
4. Â¶ÇÊûú‰ø°ÊÅØ‰∏çË∂≥ÔºåÊòéÁ°ÆÊåáÂá∫Âì™‰∫õÊñπÈù¢ÈúÄË¶ÅÊõ¥Â§ö‰ø°ÊÅØ

ËØ∑Áõ¥Êé•ÁªôÂá∫ÊúÄÁªàÁ≠îÊ°àÔºå‰∏çÈúÄË¶ÅÂÜçËøõË°åÊêúÁ¥¢„ÄÇÁ≠îÊ°àÂ∫îËØ•Ôºö
- ÂÆåÊï¥ÂõûÁ≠îÁî®Êà∑ÁöÑÈóÆÈ¢ò
- Âü∫‰∫éÂ∑≤Êî∂ÈõÜÁöÑ‰ø°ÊÅØ
- ÁªìÊûÑÊ∏ÖÊô∞ÔºåÊòì‰∫éÁêÜËß£
- ÂåÖÂê´ÂÖ∑‰ΩìÁöÑÂª∫ËÆÆÊàñÁªìËÆ∫ÔºàÂ¶ÇÊûúÈÄÇÁî®Ôºâ

ÊúÄÁªàÁ≠îÊ°à:"""

            if self.debug_mode and not self.silent_mode:
                print("ü§ñ Ë∞ÉÁî®AIÁîüÊàêÊúÄÁªàÁªìÊûú...")
            
            # Áõ¥Êé•Ë∞ÉÁî®ÊèêÁ§∫ÁîüÊàêÊúÄÁªàÁ≠îÊ°à
            response = await self.prompt.run({
                "current_date": self.current_date,
                "task": finalize_prompt,
                "workspace": "",  # ‰∏çÈúÄË¶ÅÂ∑•‰ΩúÁ©∫Èó¥
                "tool_records": [],  # ‰∏çÈúÄË¶ÅÂ∑•ÂÖ∑ËÆ∞ÂΩï
            })
            
            # Ê∏ÖÁêÜÂìçÂ∫îÔºàÁßªÈô§ÊÄùËÄÉÈÉ®ÂàÜÔºâ
            final_answer = re.sub(r"(?:<think>)?.*?</think>", "", response, flags=re.DOTALL).strip()
            
            if self.debug_mode and not self.silent_mode:
                print(f"‚úÖ ÊúÄÁªàÁªìÊûúÁîüÊàêÂÆåÊàêÔºåÈïøÂ∫¶: {len(final_answer)} Â≠óÁ¨¶")
            
            # Êõ¥Êñ∞Â∑•‰ΩúÁ©∫Èó¥Áä∂ÊÄÅ‰∏∫ÂÆåÊàê
            self.workspace.update_blocks("DONE", [], final_answer)
            
            # ÂèëÈÄÅÂÆåÊàêÁä∂ÊÄÅ
            result = {
                "answer": final_answer,
                "iterations": self.iteration_results,
                "total_rounds": self.round,
                "generation_method": "finalize_from_existing_data",
                "completedAt": datetime.now().isoformat()
            }
            
            await self.send_update("complete", result)
            
            return {
                "search_id": self.search_id,
                "iterations": self.iteration_results,
                "final_state": self.workspace.to_string(),
                "is_complete": True,
                "answer": final_answer,
                "total_rounds": self.round,
                "generation_method": "finalize_from_existing_data"
            }
            
        except Exception as e:
            error_msg = f"ÁîüÊàêÊúÄÁªàÁªìÊûúÂ§±Ë¥•: {str(e)}"
            if self.debug_mode and not self.silent_mode:
                print(f"‚ùå {error_msg}")
                print(traceback.format_exc())
            
            await self.send_update("error", {
                "error": error_msg,
                "traceback": traceback.format_exc()
            })
            
            return {
                "error": error_msg,
                "success": False
            }

    async def enhanced_search_flow(self, max_rounds: int = 5) -> Dict[str, Any]:
        """Â¢ûÂº∫ÊêúÁ¥¢ÊµÅÁ®ãÔºöÊîØÊåÅÁî®Êà∑‰∫§‰∫í"""
        if self.debug_mode and not self.silent_mode:
            print("üîÑ ÂêØÂä®Â¢ûÂº∫ÊêúÁ¥¢ÊµÅÁ®ã...")
        
        # Ê≠£Â∏∏ÊâßË°åÊêúÁ¥¢
        result = await self.run(max_rounds=max_rounds)
        
        # Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÁî®Êà∑‰∫§‰∫í
        if not result.get('is_complete') and result.get('total_rounds', 0) >= max_rounds:
            if self.debug_mode and not self.silent_mode:
                print("‚è∞ ÊêúÁ¥¢ËææÂà∞ÊúÄÂ§ßËΩÆÊ¨°ÔºåÁ≠âÂæÖÁî®Êà∑ÂÜ≥Á≠ñ...")
            
            # ÂèëÈÄÅÁ≠âÂæÖÁî®Êà∑ÂÜ≥Á≠ñÁä∂ÊÄÅ
            await self.send_update("waiting_user_decision", {
                "message": "ÊêúÁ¥¢ËææÂà∞ÊúÄÂ§ßËΩÆÊ¨°ÔºåÁ≠âÂæÖÁî®Êà∑ÂÜ≥Á≠ñ",
                "iterations": result.get('iterations', []),
                "final_state": result.get('final_state', ''),
                "options": ["continue", "finalize"]
            })
            
            # Á≠âÂæÖÁî®Êà∑ÈÄâÊã©
            user_action = await self.wait_for_user_decision()
            
            if user_action == 'continue':
                if self.debug_mode and not self.silent_mode:
                    print("üë§ Áî®Êà∑ÈÄâÊã©ÔºöÁªßÁª≠ÊêúÁ¥¢")
                # ÁªßÁª≠ÊêúÁ¥¢È¢ùÂ§ñËΩÆÊ¨°
                continue_result = await self.continue_search_in_same_env(3)
                return continue_result
            elif user_action == 'finalize':
                if self.debug_mode and not self.silent_mode:
                    print("üë§ Áî®Êà∑ÈÄâÊã©ÔºöÁîüÊàêÊúÄÁªàÁªìÊûú")
                # Âü∫‰∫éÁé∞Êúâ‰ø°ÊÅØÁîüÊàêÊúÄÁªàÁªìÊûú
                final_result = await self.finalize_with_current_state()
                return final_result
            else:
                if self.debug_mode and not self.silent_mode:
                    print("‚è∞ Áî®Êà∑ÂÜ≥Á≠ñË∂ÖÊó∂ÔºåËá™Âä®ÁîüÊàêÊúÄÁªàÁªìÊûú")
                # Ë∂ÖÊó∂Êó∂Ëá™Âä®ÁîüÊàêÊúÄÁªàÁªìÊûú
                timeout_result = await self.finalize_with_current_state()
                timeout_result['timeout_finalized'] = True
                return timeout_result
        
        return result

    async def run_tool(self, tool_id: str, tool_input: str, context: str | None = None) -> str:
        """ÊâßË°åÂ∑•ÂÖ∑Ë∞ÉÁî®"""
        try:
            assert tool_id in ["search", "scrape"], f"Illegal tool: {tool_id}"
            tool = self.tools[tool_id]
            result = await tool(tool_input, context)
            return result
        except Exception as e:
            if self.debug_mode and not self.silent_mode:
                print(f"‚ùå Failed to run tool {e}")
                print(traceback.format_exc())
            return f"Tool execution failed: {e}"

    async def run(self, max_rounds: int = 5) -> Dict[str, Any]:
        """ËøêË°åÊêúÁ¥¢‰ª£ÁêÜ"""
        
        if self.debug_mode and not self.silent_mode:
            print("üîÑ ÊêúÁ¥¢‰ª£ÁêÜÂºÄÂßãËøêË°å...")
        
        # ÂèëÈÄÅÂàùÂßãÁä∂ÊÄÅ
        if self.debug_mode and not self.silent_mode:
            print("üì§ ÂèëÈÄÅÂàùÂßãÁä∂ÊÄÅÊõ¥Êñ∞...")
        await self.send_update("start", {"task": self.task})
        if self.debug_mode and not self.silent_mode:
            print("‚úÖ ÂàùÂßãÁä∂ÊÄÅÊõ¥Êñ∞ÂèëÈÄÅÂÆåÊàê")
        
        consecutive_failures = 0
        total_tool_calls = 0
        
        while self.round < max_rounds:
            try:
                if self.debug_mode and not self.silent_mode:
                    print(f"\nüîÑ === Round {self.round + 1} ===")
                    print(f"ü§ñ ÂáÜÂ§áË∞ÉÁî®OpenRouter API...")
                    print(f"üìù PromptÂèÇÊï∞: task={self.task[:50]}..., workspaceÈïøÂ∫¶={len(self.workspace.to_string())}")
                
                response = await self.prompt.run({
                    "current_date": self.current_date,
                    "task": self.task,
                    "workspace": self.workspace.to_string(),
                    "tool_records": self.tool_records,
                })
                
                if self.debug_mode and not self.silent_mode:
                    print(f"‚úÖ OpenRouter APIË∞ÉÁî®ÊàêÂäüÔºåÂìçÂ∫îÈïøÂ∫¶: {len(response)}")
                    print(f"üìÑ ÂìçÂ∫îÂâç200Â≠óÁ¨¶: {response[:200]}...")

                # Ê∏ÖÈô§ÊÄùËÄÉÈÉ®ÂàÜ
                response = re.sub(r"(?:<think>)?.*?</think>", "", response, flags=re.DOTALL)
                
                if self.debug_mode and not self.silent_mode:
                    print("üîç ÂºÄÂßãÊèêÂèñJSONÂìçÂ∫î...")
                # ÊèêÂèñJSONÂìçÂ∫î
                response_json = extract_largest_json(response)
                
                if not response_json:
                    if self.debug_mode and not self.silent_mode:
                        print("‚ùå Failed to extract JSON from response")
                        print(f"üìÑ ÂÆåÊï¥ÂìçÂ∫î: {response}")
                    break
                
                if self.debug_mode and not self.silent_mode:
                    print(f"‚úÖ JSONÊèêÂèñÊàêÂäü: {list(response_json.keys())}")

                # Ê£ÄÊü•ÊòØÂê¶ËøáÊó©ÁªìÊùü - ‰ΩøÁî®Êõ¥Êô∫ËÉΩÁöÑËá™ÊàëÂèçÁúÅÊú∫Âà∂
                status_update = response_json.get("status_update", "IN_PROGRESS")
                answer = response_json.get("answer", "")
                
                # Ëá™ÊàëÂèçÁúÅÔºöÂú®ÁªìÊùüÂâçÊ£ÄÊü•Á≠îÊ°àË¥®Èáè
                if status_update == "DONE":
                    need_continue = False
                    reflection_reasons = []
                    
                    # Ê£ÄÊü•Á≠îÊ°àË¥®Èáè
                    if not answer or len(answer.strip()) < 100:
                        need_continue = True
                        reflection_reasons.append("Á≠îÊ°àËøáÁü≠ÔºåÈúÄË¶ÅÊõ¥ËØ¶ÁªÜÁöÑ‰ø°ÊÅØ")
                    
                    # Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´ÈîôËØØÊåáÁ§∫
                    error_indicators = ["failed", "error", "Êó†Ê≥ï", "‰∏çËÉΩ", "Êâæ‰∏çÂà∞", "Êó†‰ø°ÊÅØ"]
                    if any(indicator in answer.lower() for indicator in error_indicators):
                        need_continue = True
                        reflection_reasons.append("Á≠îÊ°àÂåÖÂê´ÈîôËØØÊåáÁ§∫ÔºåÈúÄË¶ÅÂ∞ùËØïÂÖ∂‰ªñÊêúÁ¥¢Á≠ñÁï•")
                    
                    # Ê£ÄÊü•ÊòØÂê¶Âú®Êó©ÊúüËΩÆÊ¨°‰∏îÂ∑•ÂÖ∑Ë∞ÉÁî®ÊàêÂäüÁéá‰Ωé
                    if self.round < 2 and total_tool_calls < 3:
                        need_continue = True
                        reflection_reasons.append("Êó©ÊúüËΩÆÊ¨°‰∏îÂ∑•ÂÖ∑Ë∞ÉÁî®ËæÉÂ∞ëÔºåÂ∫îËØ•Â∞ùËØïÊõ¥Â§öÊêúÁ¥¢Ë∑ØÂæÑ")
                    
                    # Ê£ÄÊü•ÊòØÂê¶ÊúâË∂≥Â§üÁöÑ‰ø°ÊÅØÊù•Ê∫ê
                    tool_calls = response_json.get("tool_calls", [])
                    if len(tool_calls) < 2 and self.round < 4:
                        need_continue = True
                        reflection_reasons.append("‰ø°ÊÅØÊù•Ê∫ê‰∏çË∂≥ÔºåÈúÄË¶ÅÊõ¥Â§öÊ†∑ÂåñÁöÑÊêúÁ¥¢")
                    
                    # Â¶ÇÊûúÈúÄË¶ÅÁªßÁª≠ÔºåÂº∫Âà∂ËÆæÁΩÆ‰∏∫IN_PROGRESS
                    if need_continue:
                        if self.debug_mode and not self.silent_mode:
                            print(f"ü§î Ëá™ÊàëÂèçÁúÅÔºöÊ£ÄÊµãÂà∞ÈúÄË¶ÅÁªßÁª≠ÊêúÁ¥¢")
                            for reason in reflection_reasons:
                                print(f"   - {reason}")
                        
                        response_json["status_update"] = "IN_PROGRESS"
                        if "memory_updates" not in response_json:
                            response_json["memory_updates"] = []
                        
                        # Ê∑ªÂä†ÂèçÁúÅËÆ∞ÂøÜÂùó
                        response_json["memory_updates"].append({
                            "operation": "add",
                            "content": f"Ëá™ÊàëÂèçÁúÅ (Á¨¨{self.round + 1}ËΩÆ): {'; '.join(reflection_reasons)}„ÄÇÈúÄË¶ÅÁªßÁª≠Êé¢Á¥¢Êõ¥Â§ö‰ø°ÊÅØÊ∫êÂíåÊêúÁ¥¢Á≠ñÁï•„ÄÇ"
                        })
                        
                        # Â¶ÇÊûúÊ≤°ÊúâÂ∑•ÂÖ∑Ë∞ÉÁî®ÔºåÊ∑ªÂä†Âª∫ËÆÆÁöÑË∞ÉÁî®
                        if not response_json.get("tool_calls"):
                            # Âü∫‰∫é‰ªªÂä°ÁîüÊàêÊõ¥Êô∫ËÉΩÁöÑÊêúÁ¥¢Êü•ËØ¢
                            task_keywords = self.task.split()[:3]  # ÂèñÂâç3‰∏™ÂÖ≥ÈîÆËØç
                            response_json["tool_calls"] = [
                                {"tool": "search", "input": f"{self.task} ËØ¶ÁªÜËß£Èáä"},
                                {"tool": "search", "input": f"{' '.join(task_keywords)} ÊúÄÊñ∞‰ø°ÊÅØ"}
                            ]
                            
                            # Â¶ÇÊûúËΩÆÊ¨°ËæÉÂ∞ëÔºåÊ∑ªÂä†Êõ¥Â§öÊêúÁ¥¢ËßíÂ∫¶
                            if self.round < 2:
                                response_json["tool_calls"].append(
                                    {"tool": "search", "input": f"{self.task} ÂÆåÊï¥ÊåáÂçó"}
                                )
                    else:
                        if self.debug_mode and not self.silent_mode:
                            print("‚úÖ Ëá™ÊàëÂèçÁúÅÔºöÁ≠îÊ°àË¥®ÈáèËâØÂ•ΩÔºåÂèØ‰ª•ÁªìÊùüÊêúÁ¥¢")
                
                # È¢ùÂ§ñÁöÑËá™ÊàëÂèçÁúÅÔºöÊ£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊõ¥Ê∑±ÂÖ•ÁöÑÊêúÁ¥¢
                if status_update == "IN_PROGRESS" and self.round >= 3:
                    # Ê£ÄÊü•ÊúÄËøëÂá†ËΩÆÊòØÂê¶ÊúâËøõÂ±ï
                    recent_iterations = self.iteration_results[-2:] if len(self.iteration_results) >= 2 else []
                    if recent_iterations:
                        # ÁÆÄÂçïÊ£ÄÊü•ÔºöÂ¶ÇÊûúÊúÄËøëÁöÑÂ∑•ÂÖ∑Ë∞ÉÁî®ÈÉΩÂ§±Ë¥•‰∫ÜÔºåÂ∞ùËØï‰∏çÂêåÁ≠ñÁï•
                        recent_tool_calls = sum(len(it.get("tool_calls", [])) for it in recent_iterations)
                        if recent_tool_calls == 0:
                            if "memory_updates" not in response_json:
                                response_json["memory_updates"] = []
                            response_json["memory_updates"].append({
                                "operation": "add",
                                "content": f"Á≠ñÁï•Ë∞ÉÊï¥ (Á¨¨{self.round + 1}ËΩÆ): ÊúÄËøëËΩÆÊ¨°Â∑•ÂÖ∑Ë∞ÉÁî®ËæÉÂ∞ëÔºåÂ∞ùËØïÊõ¥Âü∫Á°ÄÁöÑÊêúÁ¥¢ËØçÊ±á„ÄÇ"
                            })
                            
                            # Ê∑ªÂä†Êõ¥Âü∫Á°ÄÁöÑÊêúÁ¥¢
                            basic_terms = self.task.replace("Â¶Ç‰Ωï", "").replace("‰ªÄ‰πàÊòØ", "").strip()
                            if not response_json.get("tool_calls"):
                                response_json["tool_calls"] = [{"tool": "search", "input": basic_terms}]
                
                if self.debug_mode and not self.silent_mode:
                    print("üìù Êõ¥Êñ∞Â∑•‰ΩúÁ©∫Èó¥...")
                # Êõ¥Êñ∞Â∑•‰ΩúÂå∫
                self.workspace.update_blocks(
                    response_json.get("status_update", "IN_PROGRESS"),
                    response_json.get("memory_updates", []),
                    response_json.get("answer", None),
                )
                if self.debug_mode and not self.silent_mode:
                    print("‚úÖ Â∑•‰ΩúÁ©∫Èó¥Êõ¥Êñ∞ÂÆåÊàê")
                
                # ËÆ∞ÂΩïËø≠‰ª£ÁªìÊûú
                iteration_result = {
                    "round": self.round + 1,
                    "workspace_state": self.workspace.to_string(),
                    "tool_calls": response_json.get("tool_calls", []),
                    "response_json": response_json,
                    "raw_response": response[:500] + "..." if len(response) > 500 else response
                }
                
                self.iteration_results.append(iteration_result)
                
                if self.debug_mode and not self.silent_mode:
                    print("üì§ ÂèëÈÄÅËø≠‰ª£Êõ¥Êñ∞...")
                # ÂèëÈÄÅËø≠‰ª£Êõ¥Êñ∞
                await self.send_update("iteration", iteration_result)
                if self.debug_mode and not self.silent_mode:
                    print("‚úÖ Ëø≠‰ª£Êõ¥Êñ∞ÂèëÈÄÅÂÆåÊàê")

                # Ê£ÄÊü•ÊòØÂê¶Â∑≤ÂÆåÊàêÔºà‰ΩøÁî®Êõ¥Êñ∞ÂêéÁöÑÁä∂ÊÄÅÔºâ
                if self.workspace.is_done():
                    if self.debug_mode and not self.silent_mode:
                        print("üéâ ‰ªªÂä°Â∑≤ÂÆåÊàê!")
                    final_answer = response_json.get("answer", "")
                    await self.send_update("complete", {
                        "answer": final_answer,
                        "iterations": self.iteration_results,
                        "total_rounds": self.round + 1
                    })
                    break

                # ÊâßË°åÂ∑•ÂÖ∑Ë∞ÉÁî®
                tool_calls = response_json.get("tool_calls", [])
                if not tool_calls:
                    if self.debug_mode and not self.silent_mode:
                        print("‚ö†Ô∏è No tool calls in response")
                    consecutive_failures += 1
                    
                    # Â¶ÇÊûúËøûÁª≠Â§öËΩÆÊ≤°ÊúâÂ∑•ÂÖ∑Ë∞ÉÁî®Ôºå‰∏îËΩÆÊï∞Ëøò‰∏çÂ§öÔºåÂº∫Âà∂ÁªßÁª≠
                    if consecutive_failures >= 2 and self.round < max_rounds - 1:
                        if self.debug_mode and not self.silent_mode:
                            print("üîÑ Adding fallback search to continue exploration...")
                        tool_calls = [{"tool": "search", "input": f"information about {self.task}"}]
                    else:
                        break
                else:
                    consecutive_failures = 0
                
                total_tool_calls += len(tool_calls)
                
                if self.debug_mode and not self.silent_mode:
                    print(f"üõ†Ô∏è ÊâßË°å {len(tool_calls)} ‰∏™Â∑•ÂÖ∑Ë∞ÉÁî®...")
                    for i, call in enumerate(tool_calls):
                        print(f"  {i+1}. {call['tool']}: {call['input'][:100]}...")
                
                tasks = [
                    self.run_tool(call["tool"], call["input"], self.task)
                    for call in tool_calls
                ]
                
                if self.debug_mode and not self.silent_mode:
                    print("‚ö†Ô∏è ÂºÄÂßãÂπ∂ÂèëÊâßË°åÂ∑•ÂÖ∑ - ËøôÈáåÂèØËÉΩ‰ºöÂç°‰Ωè...")
                tool_outputs = await asyncio.gather(*tasks)
                if self.debug_mode and not self.silent_mode:
                    print("‚úÖ Â∑•ÂÖ∑ÊâßË°åÂÆåÊàê!")
                
                # Ê£ÄÊü•Â∑•ÂÖ∑ËæìÂá∫Ë¥®Èáè
                successful_outputs = 0
                for i, output in enumerate(tool_outputs):
                    if output and not output.startswith("Tool execution failed") and not "failed" in output.lower():
                        successful_outputs += 1
                    if self.debug_mode and not self.silent_mode:
                        print(f"  Â∑•ÂÖ∑ {i+1} ËæìÂá∫ÈïøÂ∫¶: {len(output)}")
                
                if self.debug_mode and not self.silent_mode:
                    print(f"üìä Tool success rate this round: {successful_outputs}/{len(tool_calls)}")
                
                # ËÆ∞ÂΩïÂ∑•ÂÖ∑ËæìÂá∫
                tool_records = [
                    {**call, "output": output}
                    for call, output in zip(tool_calls, tool_outputs)
                ]
                
                # Â∞ÜÂ∑•ÂÖ∑ËæìÂá∫Ê∑ªÂä†Âà∞‰∏ã‰∏ÄËΩÆ
                self.tool_records = tool_records

            except Exception as e:
                if self.debug_mode and not self.silent_mode:
                    print(f"‚ùå Error in agent loop: {str(e)}")
                    print(traceback.format_exc())
                await self.send_update("error", {"error": str(e), "traceback": traceback.format_exc()})
                break
            
            # Â¢ûÂä†ËΩÆÊ¨°ËÆ°Êï∞
            self.round += 1
            
            if self.debug_mode and not self.silent_mode:
                print(f"üò¥ ËΩÆÊ¨° {self.round} ÂÆåÊàêÔºå‰ºëÊÅØ2Áßí...")
            # GitHub Actions‰∏≠Á®çÂæÆÂª∂ËøüÈÅøÂÖçAPIÈôêÂà∂
            await asyncio.sleep(2)
        
        if self.debug_mode and not self.silent_mode:
            print("üèÅ ÊêúÁ¥¢Âæ™ÁéØÁªìÊùü")
        
        # Â¶ÇÊûúËææÂà∞ÊúÄÂ§ßËΩÆÊï∞‰ΩÜ‰ªªÂä°Êú™ÂÆåÊàê
        if not self.workspace.is_done() and self.round >= max_rounds:
            if self.debug_mode and not self.silent_mode:
                print("‚è∞ ËææÂà∞ÊúÄÂ§ßËΩÆÊï∞ÈôêÂà∂")
            # ÁîüÊàêÊÄªÁªìÊÄßÁ≠îÊ°à
            summary_answer = f"ÊêúÁ¥¢ÂÆåÊàê {self.round} ËΩÆËø≠‰ª£ÔºåÂÖ±ÊâßË°å {total_tool_calls} Ê¨°Â∑•ÂÖ∑Ë∞ÉÁî®„ÄÇ"
            
            if total_tool_calls == 0:
                summary_answer += "Áî±‰∫éÂ∑•ÂÖ∑Ë∞ÉÁî®Â§±Ë¥•ÔºåÊó†Ê≥ïËé∑ÂèñÂ§ñÈÉ®‰ø°ÊÅØÊù•ÂõûÁ≠îÊü•ËØ¢„ÄÇ"
            else:
                summary_answer += "Âü∫‰∫éÂèØÁî®‰ø°ÊÅØÔºåÂ∑≤Â∞ùËØïÂ§öÁßçÊêúÁ¥¢Á≠ñÁï•„ÄÇ"
            
            await self.send_update("timeout", {
                "message": f"Reached maximum {max_rounds} rounds without completion",
                "iterations": self.iteration_results,
                "final_state": self.workspace.to_string(),
                "summary": summary_answer
            })
        
        if self.debug_mode and not self.silent_mode:
            print("üìã ÂáÜÂ§áËøîÂõûÊúÄÁªàÁªìÊûú...")
        final_result = {
            "search_id": self.search_id,
            "iterations": self.iteration_results,
            "final_state": self.workspace.to_string(),
            "is_complete": self.workspace.is_done(),
            "answer": self.workspace.state.get("answer"),
            "total_rounds": self.round,
            "total_tool_calls": total_tool_calls
        }
        if self.debug_mode and not self.silent_mode:
            print("‚úÖ ÊúÄÁªàÁªìÊûúÂáÜÂ§áÂÆåÊàê")
        
        return final_result


class GitHubRunner:
    """GitHub Actions ËøêË°åÂô®"""
    
    def __init__(self):
        self.settings = get_settings()

    async def run_iterative_search(self, query: str, callback_url: str = None, max_rounds: int = 5, search_id: str = None, debug_mode: bool = False, silent_mode: bool = False) -> Dict[str, Any]:
        """ËøêË°åËø≠‰ª£ÊêúÁ¥¢"""
        try:
            if debug_mode and not silent_mode:
                print(f"üîÑ ÂºÄÂßãËø≠‰ª£ÊêúÁ¥¢: {query}")
                print(f"üìû ÂõûË∞ÉURL: {callback_url}")
                print(f"üîÑ ÊúÄÂ§ßËΩÆÊï∞: {max_rounds}")
                print("üìù ÂàõÂª∫ÊêúÁ¥¢‰ª£ÁêÜ‰∏≠...")
            
            # ÂàõÂª∫ÊêúÁ¥¢‰ª£ÁêÜ
            agent = GitHubSearchAgent(
                task=query,
                callback_url=callback_url,
                search_id=search_id,
                debug_mode=debug_mode,
                silent_mode=silent_mode
            )
            
            if debug_mode and not silent_mode:
                print("‚úÖ ÊêúÁ¥¢‰ª£ÁêÜÂàõÂª∫ÊàêÂäü")
                print(f"üÜî ÊêúÁ¥¢ID: {agent.search_id}")
                print("üéØ ÂºÄÂßãËøêË°åÊêúÁ¥¢‰ª£ÁêÜ...")
                print("‚ö†Ô∏è  ËøôÈáåÂèØËÉΩ‰ºöÂç°‰Ωè - ÁõëÊéß‰∏≠...")
            
            # ËøêË°åÊêúÁ¥¢
            result = await agent.run(max_rounds=max_rounds)
            
            if debug_mode and not silent_mode:
                print("‚úÖ ÊêúÁ¥¢‰ª£ÁêÜËøêË°åÂÆåÊàê!")
                print(f"üìä ÊêúÁ¥¢ÁªìÊûúÊ¶ÇËßà: is_complete={result.get('is_complete')}, total_rounds={result.get('total_rounds')}")
            
            return result
            
        except Exception as e:
            error_result = {
                "error": f"Ëø≠‰ª£ÊêúÁ¥¢Â§±Ë¥•: {str(e)}",
                "success": False
            }
            if debug_mode and not silent_mode:
                print(f"‚ùå ÊêúÁ¥¢ËøáÁ®ãÂèëÁîüÈîôËØØ: {error_result}")
                traceback.print_exc()
            return error_result

    async def run_from_env(self) -> Dict[str, Any]:
        """‰ªéÁéØÂ¢ÉÂèòÈáèËøêË°åÊêúÁ¥¢"""
        try:
            # ‰ªéÁéØÂ¢ÉÂèòÈáèËé∑ÂèñÂèÇÊï∞
            query = os.getenv("SEARCH_QUERY")
            if not query:
                return {
                    "error": "ÁéØÂ¢ÉÂèòÈáè SEARCH_QUERY Êú™ËÆæÁΩÆ",
                    "success": False
                }
            
            callback_url = os.getenv("CALLBACK_URL")
            max_rounds = int(os.getenv("MAX_ROUNDS") or "5")
            debug_mode = os.getenv("DEBUG_MODE", "false").lower() == "true"
            
            if debug_mode:
                print(f"üîç ‰ªéÁéØÂ¢ÉÂèòÈáèÂºÄÂßãÊêúÁ¥¢: {query}")
            
            # ÊâßË°åËø≠‰ª£ÊêúÁ¥¢
            search_id = os.getenv("WORKSPACE_ID", f"search-{int(datetime.now().timestamp() * 1000)}")
            result = await self.run_iterative_search(query, callback_url, max_rounds, search_id, debug_mode)
            
            return result
            
        except Exception as e:
            error_result = {
                "error": f"ÁéØÂ¢ÉÂèòÈáèÊâßË°åÂ§±Ë¥•: {str(e)}",
                "success": False
            }
            print(f"‚ùå ÈîôËØØ: {error_result}")
            return error_result

    def check_environment(self) -> Dict[str, Any]:
        """Ê£ÄÊü•ËøêË°åÁéØÂ¢É"""
        env_info = {
            "platform": sys.platform,
            "python_version": sys.version,
            "github_actions": os.getenv("GITHUB_ACTIONS") == "true",
            "github_repository": os.getenv("GITHUB_REPOSITORY"),
            "github_ref": os.getenv("GITHUB_REF"),
            "github_sha": os.getenv("GITHUB_SHA"),
            "runner_os": os.getenv("RUNNER_OS"),
            "api_keys_available": {
                "openrouter": bool(os.getenv("OPENROUTER_API_KEY")),
                "jina": bool(os.getenv("JINA_API_KEY"))
            }
        }
        
        print("üîß ËøêË°åÁéØÂ¢É‰ø°ÊÅØ:")
        for key, value in env_info.items():
            print(f"  {key}: {value}")
        
        return env_info

    def validate_environment(self) -> tuple[bool, list[str]]:
        """È™åËØÅÁéØÂ¢ÉÊòØÂê¶Êª°Ë∂≥ËøêË°åË¶ÅÊ±Ç"""
        errors = []
        
        # Ê£ÄÊü•ÂøÖÈúÄÁöÑ API ÂØÜÈí•
        if not os.getenv("OPENROUTER_API_KEY"):
            errors.append("Áº∫Â∞ë OPENROUTER_API_KEY ÁéØÂ¢ÉÂèòÈáè")
        
        if not os.getenv("JINA_API_KEY"):
            errors.append("Áº∫Â∞ë JINA_API_KEY ÁéØÂ¢ÉÂèòÈáè")
        
        # Ê£ÄÊü• Python ÁâàÊú¨
        if sys.version_info < (3, 8):
            errors.append(f"Python ÁâàÊú¨Ëøá‰Ωé: {sys.version}ÔºåÈúÄË¶Å 3.8+")
        
        return len(errors) == 0, errors


# CLI ÂÖ•Âè£ÂáΩÊï∞
async def main():
    """‰∏ªÂáΩÊï∞ - CLI ÂÖ•Âè£"""
    # Ëß£ÊûêÂëΩ‰ª§Ë°åÂèÇÊï∞
    parser = argparse.ArgumentParser(description='DeepSeek ÊêúÁ¥¢‰ª£ÁêÜ')
    parser.add_argument('--interactive', action='store_true', 
                       help='ÂêØÁî®Áî®Êà∑‰∫§‰∫íÊ®°ÂºèÔºàÁ≠âÂæÖÁî®Êà∑ÂÜ≥Á≠ñÔºâ')
    parser.add_argument('--mode', choices=['normal', 'interactive'], default='normal',
                       help='ËøêË°åÊ®°ÂºèÔºönormalÔºàÊ≠£Â∏∏Ê®°ÂºèÔºâÊàñ interactiveÔºà‰∫§‰∫íÊ®°ÂºèÔºâ')
    args = parser.parse_args()
    
    runner = GitHubRunner()
    
    # Ê£ÄÊü•ÂíåÈ™åËØÅÁéØÂ¢É
    print("üöÄ ÂêØÂä® DeepSeek ÊêúÁ¥¢‰ª£ÁêÜ")
    
    # ‰ªé GitHub Actions ÁéØÂ¢ÉÂèòÈáèËé∑ÂèñÂèÇÊï∞
    query = os.getenv("SEARCH_QUERY")
    callback_url = os.getenv("CALLBACK_URL")
    max_rounds = int(os.getenv("MAX_ROUNDS") or "5")
    include_scraping = os.getenv("INCLUDE_SCRAPING", "true").lower() == "true"
    workspace_id = os.getenv("WORKSPACE_ID", f"ws-{int(datetime.now().timestamp() * 1000)}")
    environment = os.getenv("ENVIRONMENT", "production")
    debug_mode = os.getenv("DEBUG_MODE", "false").lower() == "true"
    silent_mode = os.getenv("SILENT_MODE", "false").lower() == "true"
    
    # Ê£ÄÊü•ÊòØÂê¶ÂêØÁî®Áî®Êà∑‰∫§‰∫í
    enable_user_interaction = (args.interactive or 
                             args.mode == 'interactive' or 
                             os.getenv("ENABLE_USER_INTERACTION", "false").lower() == "true")

    if debug_mode and not silent_mode:
        print(f"üìã ÊêúÁ¥¢Êü•ËØ¢: {query}")
        print(f"üìû ÂõûË∞É URL: {callback_url}")
        print(f"üè† Â∑•‰ΩúÁ©∫Èó¥: {workspace_id}")
        print(f"üîÑ ÊúÄÂ§ßËΩÆÊï∞: {max_rounds}")
        print(f"üîß ÂåÖÂê´ÊäìÂèñ: {include_scraping}")
        print(f"üåç ÁéØÂ¢É: {environment}")
        print(f"üêõ Ë∞ÉËØïÊ®°Âºè: {debug_mode}")
        print(f"üîá ÈùôÈªòÊ®°Âºè: {silent_mode}")
        print(f"ü§ù Áî®Êà∑‰∫§‰∫íÊ®°Âºè: {enable_user_interaction}")
        
        runner.check_environment()
    elif not silent_mode:
        print("üîç ÊêúÁ¥¢‰ªªÂä°ËøõË°å‰∏≠...")
    
    is_valid, errors = runner.validate_environment()
    if not is_valid:
        if not silent_mode:
            print("‚ùå ÁéØÂ¢ÉÈ™åËØÅÂ§±Ë¥•:")
            for error in errors:
                print(f"  - {error}")
        sys.exit(1)
    
    if not silent_mode:
        print("‚úÖ ÁéØÂ¢ÉÈ™åËØÅÈÄöËøá")
    
    if not query:
        if not silent_mode:
            print("‚ùå Áº∫Â∞ëÊêúÁ¥¢Êü•ËØ¢ÂèÇÊï∞ (SEARCH_QUERY)")
        sys.exit(1)
    
    try:
        if enable_user_interaction:
            # ÂêØÁî®Áî®Êà∑‰∫§‰∫íÊ®°Âºè
            if debug_mode and not silent_mode:
                print("ü§ù ÂêØÁî®Áî®Êà∑‰∫§‰∫íÊ®°Âºè")
            
            # ÂàõÂª∫Â¢ûÂº∫ÊêúÁ¥¢‰ª£ÁêÜ
            agent = GitHubSearchAgent(
                task=query,
                callback_url=callback_url,
                search_id=workspace_id,
                debug_mode=debug_mode,
                silent_mode=silent_mode
            )
            
            # ËøêË°åÂ¢ûÂº∫ÊêúÁ¥¢ÊµÅÁ®ã
            result = await agent.enhanced_search_flow(max_rounds=max_rounds)
        else:
            # Ê≠£Â∏∏Ê®°Âºè
            result = await runner.run_iterative_search(query, callback_url, max_rounds, workspace_id, debug_mode, silent_mode)
        
        # ËæìÂá∫ÁªìÊûú
        if not silent_mode:
            print("\n" + "=" * 50)
            print("üìã ÊâßË°åÁªìÊûú:")
            print(json.dumps(result, ensure_ascii=False, indent=2))
        
        # ËÆæÁΩÆÈÄÄÂá∫Á†Å
        if result.get("is_complete", False) or (not result.get("error")):
            if not silent_mode:
                print("‚úÖ ÊâßË°åÊàêÂäü")
            sys.exit(0)
        else:
            if not silent_mode:
                print("‚ùå ÊâßË°åÂ§±Ë¥•")
            sys.exit(1)
            
    except Exception as e:
        if not silent_mode:
            print(f"‚ùå ÊâßË°åËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ: {str(e)}")
            print(traceback.format_exc())
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main()) 